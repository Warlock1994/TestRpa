export const workflowPatternsContent = `# 🔄 工作流模式

本章介绍常用的工作流设计模式和最佳实践，帮助你构建更健壮、更高效的自动化流程。

---

## 📐 基础模式

### 1. 顺序执行模式

最简单的模式，模块按顺序依次执行。

\`\`\`
模块A → 模块B → 模块C → 模块D
\`\`\`

**适用场景**：
- 简单的线性任务
- 步骤之间有严格的先后顺序

**示例**：打开网页 → 输入搜索词 → 点击搜索 → 获取结果

---

### 2. 条件分支模式

根据条件执行不同的分支。

\`\`\`
        ┌─ 条件为真 → 分支A
条件判断 ─┤
        └─ 条件为假 → 分支B
\`\`\`

**适用场景**：
- 需要根据情况做不同处理
- 错误处理和异常情况

**示例**：
\`\`\`
检查登录状态
  ├─ 已登录 → 直接执行任务
  └─ 未登录 → 先登录再执行任务
\`\`\`

---

### 3. 循环模式

重复执行一段流程。

\`\`\`
┌─────────────────┐
│  循环开始       │
│    ↓           │
│  执行操作      │←─┐
│    ↓           │  │
│  条件判断 ─────┼──┘
│    ↓ (退出)    │
│  循环结束      │
└─────────────────┘
\`\`\`

**类型**：
- **计数循环**：执行固定次数
- **条件循环**：满足条件时继续
- **遍历循环**：遍历列表元素

---

## 🏗️ 进阶模式

### 4. 重试模式

操作失败时自动重试。

\`\`\`
设置变量：重试次数 = 0
设置变量：最大重试 = 3

循环执行（{重试次数} < {最大重试}）
  ├─ 执行操作
  ├─ 条件判断：操作成功？
  │   ├─ 是 → 跳出循环
  │   └─ 否 → 重试次数 + 1
  │           等待 2000 毫秒
  └─ 跳过当前循环
\`\`\`

**配置建议**：
- 大多数模块自带重试配置
- 自定义重试可以更灵活控制

---

### 5. 状态机模式

根据当前状态决定下一步操作。

\`\`\`
设置变量：状态 = "开始"

循环执行（{状态} != "完成"）
  ├─ 条件判断：{状态} == "开始"
  │   └─ 执行初始化，状态 = "登录"
  ├─ 条件判断：{状态} == "登录"
  │   └─ 执行登录，状态 = "采集"
  ├─ 条件判断：{状态} == "采集"
  │   └─ 执行采集，状态 = "完成"
\`\`\`

**适用场景**：
- 复杂的多步骤流程
- 需要记录和恢复进度

---

### 6. 生产者-消费者模式

先收集数据，再处理数据。

\`\`\`
阶段1：生产（收集数据）
  循环采集 → 添加到列表

阶段2：消费（处理数据）
  遍历列表 → 处理每条数据
\`\`\`

**示例**：
\`\`\`
// 阶段1：收集所有商品链接
设置变量：链接列表 = []
循环翻页
  ├─ 获取当前页链接
  └─ 合并到链接列表

// 阶段2：访问每个链接采集详情
遍历列表：{链接列表}
  ├─ 打开链接
  └─ 采集详情数据
\`\`\`

**优点**：
- 分离关注点
- 便于调试和维护
- 可以先收集再批量处理

---

### 7. 管道模式

数据经过多个处理步骤，每步的输出是下一步的输入。

\`\`\`
原始数据 → 清洗 → 转换 → 验证 → 存储
\`\`\`

**示例**：
\`\`\`
获取价格文本："¥1,299.00"
  ↓
去除符号：执行JS去掉¥和逗号
  ↓
转为数字：1299
  ↓
计算折扣：1299 * 0.8 = 1039.2
  ↓
保存结果
\`\`\`

---

## 🛡️ 健壮性模式

### 8. 防御性检查模式

在关键操作前检查前置条件。

\`\`\`
// 检查页面是否正确
条件判断：页面URL包含"expected-page"
  ├─ 是 → 继续执行
  └─ 否 → 打印错误，停止执行

// 检查元素是否存在
等待元素：目标元素
  ├─ 成功 → 继续操作
  └─ 超时 → 处理异常
\`\`\`

---

### 9. 优雅降级模式

主要方法失败时，尝试备用方法。

\`\`\`
尝试方法A（首选）
  ├─ 成功 → 继续
  └─ 失败 → 尝试方法B（备选）
              ├─ 成功 → 继续
              └─ 失败 → 尝试方法C（兜底）
\`\`\`

**示例**：获取价格
\`\`\`
// 方法1：通过ID获取
获取元素信息：#price
条件判断：获取成功？
  ├─ 是 → 使用结果
  └─ 否 → 方法2：通过类名获取
          获取元素信息：.product-price
          条件判断：获取成功？
            ├─ 是 → 使用结果
            └─ 否 → 方法3：通过XPath获取
\`\`\`

---

### 10. 断点续传模式

支持从中断处继续执行。

\`\`\`
// 读取进度
读取变量：已处理索引（默认0）

// 从断点继续
遍历列表：{数据列表}
  ├─ 条件判断：{当前索引} < {已处理索引}
  │   └─ 是 → 跳过当前循环
  ├─ 处理当前数据
  └─ 保存进度：已处理索引 = {当前索引}
\`\`\`

---

## ⚡ 性能优化模式

### 11. 批量处理模式

将多个操作合并执行，减少开销。

\`\`\`
// 不好的方式：每条数据都打开新页面
遍历数据
  └─ 打开页面 → 操作 → 关闭页面

// 好的方式：在同一页面处理多条数据
打开页面
遍历数据
  └─ 操作（不关闭页面）
关闭页面
\`\`\`

---

### 12. 缓存模式

缓存重复使用的数据，避免重复获取。

\`\`\`
// 检查缓存
条件判断：{缓存数据} 存在？
  ├─ 是 → 使用缓存
  └─ 否 → 获取数据
          保存到缓存
\`\`\`

---

### 13. 并行执行模式

利用系统的真正并行执行能力，同时处理多个独立任务。

\`\`\`
        ┌─→ 任务A ─┐
开始 ──┼─→ 任务B ─┼─→ 汇合处理
        └─→ 任务C ─┘
\`\`\`

**工作原理**：
- 系统基于异步架构，支持真正的并行执行
- 当一个节点有多条输出连线时，自动并行执行
- 汇合节点会等待所有前驱分支完成

**适用场景**：
- 多个独立的API请求
- 并行发送多个通知
- 同时处理多个文件
- 无依赖的数据计算

**示例**：并行获取多个数据源
\`\`\`
开始
  ├─→ API请求：获取用户数据
  ├─→ API请求：获取订单数据
  └─→ API请求：获取商品数据
      ↓
汇合：合并所有数据并处理
\`\`\`

**注意事项**：
- 浏览器操作不建议并行（共享同一页面）
- 避免多分支同时修改同一变量
- 不要依赖并行分支的完成顺序

---

## 📋 最佳实践

### 命名规范

**变量命名**：
- 使用有意义的中文名称
- 保持一致的命名风格
- 示例：\`商品列表\`、\`当前页码\`、\`登录状态\`

**模块命名**：
- 描述模块的具体作用
- 示例：\`获取商品价格\`、\`检查登录状态\`

### 注释和日志

**关键位置添加打印日志**：
\`\`\`
打印日志：开始处理第 {当前索引} 条数据
打印日志：当前价格：{价格}
打印日志：登录状态：{登录状态}
\`\`\`

### 错误处理

**设置合理的超时**：
- 页面加载：30秒
- 元素等待：10秒
- API请求：15秒

**设置重试次数**：
- 网络操作：3次
- 点击操作：2次

### 模块化

**将重复的流程提取出来**：
- 登录流程
- 翻页流程
- 数据清洗流程

### 测试策略

1. **单元测试**：测试单个模块
2. **集成测试**：测试模块组合
3. **端到端测试**：测试完整流程

**测试步骤**：
\`\`\`
1. 先用少量数据测试
2. 检查日志和结果
3. 逐步增加数据量
4. 监控执行稳定性
\`\`\`

---

## 🎯 模式选择指南

| 场景 | 推荐模式 |
|------|----------|
| 简单线性任务 | 顺序执行 |
| 需要判断处理 | 条件分支 |
| 批量数据处理 | 循环 + 遍历 |
| 网络不稳定 | 重试模式 |
| 复杂多步骤 | 状态机 |
| 大量数据采集 | 生产者-消费者 |
| 数据转换处理 | 管道模式 |
| 提高稳定性 | 防御性检查 + 优雅降级 |
| 长时间任务 | 断点续传 |
| 性能优化 | 批量处理 + 缓存 |`
